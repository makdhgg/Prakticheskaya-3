# Практическая работа: Ассемблер и Интерпретатор для Учебной Виртуальной Машины (УВМ) - Вариант 20

## Описание

Этот репозиторий содержит реализацию ассемблера и интерпретатора для учебной виртуальной машины (УВМ), разработанных в рамках практической работы. Работа выполнена по индивидуальному заданию (вариант 20).

## Спецификация УВМ (Вариант 20)

*   **Размер команды:** 3 байта (Little-Endian).
*   **Формат команд:** `A (биты 0-3), B (остальные биты)`.
*   **Команды:**
    *   **Загрузка константы (`load`):**
        *   A = 1
        *   B = константа (18 бит)
        *   Операнд: поле B.
        *   Результат: `const_val` помещается на стек.
        *   Тест: (A=1, B=267) -> `0xB1, 0x10, 0x00`
    *   **Чтение из памяти (`read`):**
        *   A = 15
        *   B = смещение (6 бит)
        *   Операнд: значение в памяти по адресу `addr + offset`, где `addr` - элемент с вершины стека.
        *   Результат: значение из памяти помещается на стек.
        *   Тест: (A=15, B=34) -> `0x2F, 0x02, 0x00`
    *   **Запись в память (`write`):**
        *   A = 3
        *   Операнды: `value` (с вершины стека), `addr` (с вершины стека).
        *   Результат: `value` записывается в память по адресу `addr`.
        *   Тест: (A=3) -> `0x03, 0x00, 0x00`
    *   **Бинарная операция "больше" (`gt`):**
        *   A = 5
        *   B = смещение (6 бит)
        *   Операнды: `val1` (с вершины стека), `val2` (с вершины стека), `addr` (с вершины стека).
        *   Результат: `1` если `val2 > val1`, иначе `0`. Результат записывается в память по адресу `addr + offset`.
        *   Тест: (A=5, B=27) -> `0xB5, 0x01, 0x00`

## Структура репозитория

*   `12312312.py`: Ассемблер, реализующий все этапы (1, 2, 4).
*   `interpr.py`: Интерпретатор, реализующий все этапы (3, 4).
*   `*.csv`: Ассемблерные файлы, используемые для тестирования.
*   `*.bin`: Бинарные файлы, сгенерированные ассемблером.
*   `*.json`: Файлы дампа памяти, сгенерированные интерпретатором.

## Реализация этапов

### Этап 1: Перевод программы в промежуточное представление

*   **Цель:** Создание CLI-приложения ассемблера, разбор текстового представления команд и трансляция в промежуточное представление.
*   **Реализация:**
    *   Ассемблер принимает аргументы командной строки: путь к исходному CSV-файлу, путь к бинарному файлу, флаг тестового режима.
    *   Язык ассемблера использует формат CSV.
    *   Реализован транслятор из CSV в внутреннее представление (список словарей `{"op": "...", "args": [...]}`).
    *   В тестовом режиме выводится внутреннее представление в формате полей и значений.
    *   Созданы тестовые программы (например, `test_program.csv`) для проверки соответствия тестовым векторам.

### Этап 2: Формирование машинного кода

*   **Цель:** Реализация логики преобразования команд из промежуточного представления в двоичное представление.
*   **Реализация:**
    *   Реализован транслятор из промежуточного в машинное представление (функция `translate_to_machine_code_bytes` в `12312312.py`).
    *   Результат ассемблирования записывается в бинарный файл.
    *   Выводится количество ассемблированных команд и размер бинарного файла.
    *   В тестовом режиме выводится результат ассемблирования в байтовом формате, как в тесте из спецификации УВМ.
    *   Создана тестовая программа (`test_program.csv`), результат трансляции которой соответствует тестовым векторам.

### Этап 3: Интерпретатор и операции с памятью

*   **Цель:** Создание цикла интерпретации, реализация модели памяти УВМ и выполнение базовых команд.
*   **Реализация:**
    *   Интерпретатор принимает аргументы командной строки: путь к бинарному файлу, путь к файлу дампа, диапазон адресов.
    *   Для дампа используется формат JSON.
    *   Реализована модель памяти (массив) и стека (`class UVM` в `interpr.py`).
    *   Реализован основной цикл интерпретатора: чтение команды из бинарного файла, разбор, выполнение.
    *   Реализованы команды `load`, `read`, `write`.
    *   Создана тестовая программа (`copy_array_test.csv`), которая копирует массив из одной области памяти в другую, чтобы проверить корректность работы `read` и `write`. Результаты проверяются через дамп памяти (`copy_array_dump.json`).

### Этап 4: Реализация арифметико-логического устройства (АЛУ)

*   **Цель:** Завершение реализации интерпретатора, добавление поддержки вычислительных операций.
*   **Реализация:**
    *   Реализовано выполнение команды `gt` в функции `execute` в `interpr.py`.
    *   Ассемблер (`12312312.py`) был обновлён для поддержки команды `gt` в CSV-файлах.
    *   Создана тестовая программа (`gt_test.csv`), которая демонстрирует корректные вычисления с сохранением результата в память. Результаты проверяются через дамп памяти (`gt_dump.json`).

### Этап 5: Выполнение тестовой задачи

*   **Цель:** Использование разработанных ассемблера и интерпретатора для решения тестовой задачи.
*   **Реализация:**
    *   Написана, скомпилирована и исполнена программа (`stage5_task1.csv`), выполняющая поэлементное сравнение `>` над двумя векторами длины 6. Результат записывается во второй вектор.
    *   Создано три примера программ (`stage5_task1.csv`, `stage5_example1.csv`, `stage5_example2.csv`) с вычислениями над различными данными.
    *   Для всех программ выполнено ассемблирование, интерпретация и проверка дампов памяти (`stage5_task1_dump.json`, `stage5_ex1_dump.json`, `stage5_ex2_dump.json`), подтверждающих корректность выполнения.

## Использование

### Ассемблирование

```bash
python 12312312.py <input_file.csv> <output_file.bin> [--test-mode]
```

### Интерпретация

```bash
python interpr.py <binary_file.bin> <dump_file.json> <start_addr> <end_addr>
```

## Автор

makdhgg
